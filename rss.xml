<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Narusei Portal Site RSS Feed]]></title><description><![CDATA[制作物の紹介・知見共有・自身の考えなど、身の回りに起こったことをアウトプットする製作者のポータルサイトです。]]></description><link>https://narusei.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Fri, 23 Dec 2022 07:03:13 GMT</lastBuildDate><item><title><![CDATA[Bluetoothを用いてデータをMongoDBへロギングするCLIツールを作りました]]></title><description><![CDATA[この記事はTDU CPSLab Advent Calendar 2022 - Adventarの10日目の記事です 前の記事はこちらから。次の記事はこちらから。 はじめに こんにちは。都内で大学生をやっているなるせいです。 今回はBluetoothを用いてデータをMongoDB…]]></description><link>https://narusei.github.io/blog/blegger/</link><guid isPermaLink="false">https://narusei.github.io/blog/blegger/</guid><pubDate>Fri, 23 Dec 2022 16:00:00 GMT</pubDate><content:encoded>&lt;p&gt;この記事は&lt;a href=&quot;https://adventar.org/calendars/7417&quot;&gt;TDU CPSLab Advent Calendar 2022 - Adventar&lt;/a&gt;の10日目の記事です&lt;/p&gt;
&lt;p&gt;前の記事は&lt;a href=&quot;&quot;&gt;こちら&lt;/a&gt;から。次の記事は&lt;a href=&quot;&quot;&gt;こちら&lt;/a&gt;から。&lt;/p&gt;
&lt;h1&gt;はじめに&lt;/h1&gt;
&lt;p&gt;こんにちは。都内で大学生をやっているなるせいです。&lt;/p&gt;
&lt;p&gt;今回はBluetoothを用いてデータをMongoDBへロギングするCLIツールを作りましたので、記事にまとめておこうと思います。&lt;br&gt;
リポジトリは&lt;a href=&quot;https://github.com/narusei/blegger&quot;&gt;こちら&lt;/a&gt;です。&lt;/p&gt;
&lt;h1&gt;目次&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;開発環境&lt;/li&gt;
&lt;li&gt;どんなことができるの？&lt;/li&gt;
&lt;li&gt;実装内容
&lt;ul&gt;
&lt;li&gt;Bluetoothデバイスの取得&lt;/li&gt;
&lt;li&gt;MongoDBにアクセスする実装&lt;/li&gt;
&lt;li&gt;CLIツールの実装&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;確認できていないこと&lt;/li&gt;
&lt;li&gt;おわりに&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;開発環境&lt;/h1&gt;
&lt;p&gt;開発にはNode.jsにTypescriptを導入して作りました。&lt;br&gt;
使用したモジュールは以下の通りです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@abandonware/noble
&lt;ul&gt;
&lt;li&gt;Node.js内にてBluetoothを扱うためのモジュールです&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;mongodb
&lt;ul&gt;
&lt;li&gt;MongoDBサーバにアクセスするために使います&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;yargs
&lt;ul&gt;
&lt;li&gt;CLIツール化するために使うモジュールです&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;加えてMongoDBサーバをDockerを用いて立てています&lt;/p&gt;
&lt;h1&gt;どんなことができるの？&lt;/h1&gt;
&lt;p&gt;Bluetoothを扱えるマイコンにてnotifyされた際の情報を受信してMongoDBの方に格納します。&lt;br&gt;
データはStringで送信します。複数送信したい場合は以下のように送信します。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;data = data1 + &quot;,&quot; + data2 + &quot;,&quot; + data3&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;デバイス側の準備が整ったらCLIを起動します。&lt;br&gt;
CLIの扱い方は以下の通りです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ターミナルで本リポジトリ配下を開いてください
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;/blegger&lt;/code&gt;に。以下ターミナル 1 と呼称します&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ターミナルで本リポジトリ配下の mongo フォルダを開いてください
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;/blegger/mongo&lt;/code&gt;に。以下ターミナル 2 と呼称します&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ターミナル 1 で&lt;code class=&quot;language-text&quot;&gt;npm install&lt;/code&gt;します&lt;/li&gt;
&lt;li&gt;ターミナル 2 で&lt;code class=&quot;language-text&quot;&gt;docker compose up&lt;/code&gt;します
&lt;ul&gt;
&lt;li&gt;古いバージョンを使っている方は&lt;code class=&quot;language-text&quot;&gt;docker-compose up&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ターミナル 1 で以下のフォーマットに従い実行します
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;npm start -- --name=&quot;YOUR_DEVICE_LOCAL_NAME&quot; --service=&quot;YOUR_SERVICE_UUID&quot; --characteristics=&quot;YOUR_CHARACTERISTIC_UUID1&quot; &quot;YOUR_CHARACTERISTIC_UUID2&quot; --columns=&quot;DATABASE_COLUMN1&quot; &quot;DATABASE_COLUMN2&quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;オプションは以下のようになっています。&lt;br&gt;
&lt;code class=&quot;language-text&quot;&gt;npm start -- --help&lt;/code&gt;で見ることができるヘルプと同じ内容です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;name オプション
&lt;ul&gt;
&lt;li&gt;name オプションは作成した BLE デバイスのローカルネームを指します。デバイスの識別に使っています。&lt;/li&gt;
&lt;li&gt;必須オプションです。String です。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;service オプション
&lt;ul&gt;
&lt;li&gt;service オプションはサービスの UUID を指定します。&lt;/li&gt;
&lt;li&gt;必須オプションです。String です。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;characteristics オプション
&lt;ul&gt;
&lt;li&gt;characteristics はキャラクタリスティックの UUID を指定します。&lt;/li&gt;
&lt;li&gt;必須オプションです。Array&amp;#x3C;String&gt;です。配列で指定できます。columns オプションと指定した数が一致していなければなりません。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;columns オプション
&lt;ul&gt;
&lt;li&gt;columns オプションはデータベースに保存する際のコレクション名です。ひとつのキャラクタリスティックにつき、ひとつのコレクションの生成をイメージしています。&lt;/li&gt;
&lt;li&gt;必須オプションです。Array&amp;#x3C;String&gt;です。配列で指定できます。characteristics オプションと指定した数が一致していなければなりません。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正常に動作した場合は mongoDB Compassなどからデータを確認できるはずです&lt;/p&gt;
&lt;h1&gt;実装内容&lt;/h1&gt;
&lt;p&gt;本章では各実装の簡単な説明をしていきます。&lt;br&gt;
全体のコードは&lt;a href=&quot;https://github.com/narusei/blegger&quot;&gt;リポジトリ&lt;/a&gt;をご覧ください。&lt;/p&gt;
&lt;h2&gt;Bluetoothデバイスの取得&lt;/h2&gt;
&lt;p&gt;まずBluetoothを用いてNotifyしているデバイスを探します。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;noble.on(&apos;stateChange&apos;, async (state) =&gt; {
  if (state === &apos;poweredOn&apos;) {
    await noble.startScanningAsync()
  } else {
    await noble.stopScanningAsync()
  }
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Scanを開始するには&lt;code class=&quot;language-text&quot;&gt;startScanningAsync()&lt;/code&gt;を用いればいいんですが、&lt;br&gt;
その前にnobleが実装しているstateがpowerOnになっているかをチェックする必要があります。&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;noble.on(&apos;stateChange&apos;, callback(state))&lt;/code&gt;を用いることによって、&lt;br&gt;
stateが変化した際にcallbackされる形になります。&lt;/p&gt;
&lt;p&gt;この時のstateがpowerOnだった場合にScanを開始しています。&lt;/p&gt;
&lt;p&gt;ちなみに&lt;code class=&quot;language-text&quot;&gt;startScanning()&lt;/code&gt;もありますがasync/awaitで書きたかったのでAsyncの方を使っています。&lt;/p&gt;
&lt;p&gt;次にdeviceを取得する処理を行います。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;noble.on(&apos;discover&apos;, async (peripheral: noble.Peripheral) =&gt; {
  console.log(`${peripheral.advertisement.localName}`)
  if (peripheral.advertisement.localName == localName) {
    console.log(&apos;Find &apos; + peripheral.advertisement.localName + &apos;!&apos;)
  }
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常は上記のような形でdiscoverというイベントを監視して、ヒットしていったdeviceのローカルネームを見比べて該当するdeviceを引っ掛けるといった形になります。しかし私としてはこの中にドンドコ処理を書いていくのはあまり良くないかなと感じたので、Promiseで包んで非同期処理で取り出せるようにしました。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const discoveryHandler = new Promise&amp;lt;noble.Peripheral | undefined&gt;((resolve, _reject) =&gt; {
  console.log(&apos;Start Scanning...&apos;)
  noble.on(&apos;discover&apos;, async (peripheral: noble.Peripheral) =&gt; {
    console.log(`${peripheral.advertisement.localName}`)
    if (peripheral.advertisement.localName == localName) {
      console.log(&apos;Find &apos; + peripheral.advertisement.localName + &apos;!&apos;)
      resolve(peripheral)
    }
  })
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;この関数をawaitしてnoble.Peripheralを取得するイメージになります。&lt;/p&gt;
&lt;p&gt;ただ一方で、見つからないときには恐らく永遠と探し続けるのではないかと思いました。そこでtimeoutを定義する関数を作成して、Promise.raceを用いてどっちかが解決するのを待つという形を取ることにしました。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const timeoutHandler = new Promise&amp;lt;noble.Peripheral | undefined&gt;((resolve, _reject) =&gt; {
  setTimeout(() =&gt; {
    resolve(undefined)
  }, 30000)
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const device = await Promise.race([discoveryHandler, timeoutHandler])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;deviceが見つかったらListenerを全て削除します&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;noble.removeAllListeners()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上の実装を組み合わせたdeviceを取得する関数が以下の通りになります。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const waitDevice = async (localName: string) =&gt; {
  console.log(&apos;Start Scan &amp;amp; Get Target Device&apos;)
  noble.on(&apos;stateChange&apos;, async (state) =&gt; {
    if (state === &apos;poweredOn&apos;) {
      await noble.startScanningAsync()
    } else {
      await noble.stopScanningAsync()
    }
  })

  const discoveryHandler = new Promise&amp;lt;noble.Peripheral | undefined&gt;((resolve, _reject) =&gt; {
    console.log(&apos;Start Scanning...&apos;)
    noble.on(&apos;discover&apos;, async (peripheral: noble.Peripheral) =&gt; {
      console.log(`${peripheral.advertisement.localName}`)
      if (peripheral.advertisement.localName == localName) {
        console.log(&apos;Find &apos; + peripheral.advertisement.localName + &apos;!&apos;)
        resolve(peripheral)
      }
    })
  })

  const timeoutHandler = new Promise&amp;lt;noble.Peripheral | undefined&gt;((resolve, _reject) =&gt; {
    setTimeout(() =&gt; {
      resolve(undefined)
    }, 30000)
  })

  try {
    const device = await Promise.race([discoveryHandler, timeoutHandler])

    noble.removeAllListeners()

    if (device) {
      return device
    } else {
      throw new Error(&apos;Device not Found&apos;)
    }
  } catch (e) {
    throw new Error(&apos;Timeout&apos;)
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;MongoDBにアクセスする実装&lt;/h2&gt;
&lt;p&gt;次にmongoDBにアクセスする関数を用意します。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const connectMongo = async () =&gt; {
  try {
    await client.connect()
    await client.db(&apos;admin&apos;).command({ ping: 1 })
    console.log(&apos;Connected successfully to server&apos;)
  } catch (error) {
    console.log(error)
  }
}

const postMongo = async (colName: string, data: mongoDB.Document) =&gt; {
  try {
    const dbSensing = await client.db(&apos;sensing&apos;)
    const colSensing = dbSensing.collection(colName)
    const result = await colSensing.insertOne(data)
    return result
  } catch (error) {
    console.log(error)
  }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;CLIツールの実装&lt;/h2&gt;
&lt;p&gt;ここまで実装を終えたら準備は整いました。&lt;br&gt;
あとはyargsを使ってCLIツール化していきます。&lt;/p&gt;
&lt;p&gt;まずcliで受け入れるコマンドの定義をしていきます。&lt;br&gt;
前節で述べたオプションを指定していきます。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const argv = await yargs
    .option(&apos;name&apos;, {
      alias: &apos;nm&apos;,
      description: &apos;ロギングを行うデバイスのLocalNameを指定してください&apos;,
      demandOption: true,
      type: &apos;string&apos;,
    })
    .option(&apos;service&apos;, {
      alias: &apos;ser&apos;,
      description: &apos;ロギングを行いたいServiceのUUIDを指定してください&apos;,
      demandOption: true,
      type: &apos;string&apos;,
    })
    .option(&apos;characteristics&apos;, {
      alias: &apos;char&apos;,
      description: &apos;ロギングを行いたいCharacteristicのUUIDを指定してください&apos;,
      demandOption: true,
      type: &apos;array&apos;,
    })
    .option(&apos;columns&apos;, {
      alias: &apos;col&apos;,
      description: &apos;データのコレクション名を書いてください&apos;,
      demandOption: true,
      type: &apos;array&apos;,
    })
    .help().argv&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上のような感じで受け入れオプションを設定します。&lt;br&gt;
以降、&lt;code class=&quot;language-text&quot;&gt;argv.name&lt;/code&gt;といった形でユーザが入力した値を取得することができます。&lt;/p&gt;
&lt;p&gt;それでは入力値を変数に格納していきます。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const localName = argv.name ? argv.name : &apos;&apos;
const serviceUUIDs = argv.service ? [argv.service] : []
const characteristicUUIDs: string[] = argv.characteristics.map((value) =&gt; {
  return value.toString()
})
const columns: string[] = argv.columns.map((value) =&gt; {
  return value.toString()
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;また、characteristicの数はcolumnsの数と同じだけ存在する必要があります。&lt;br&gt;
columnsはDBに保管するときのデータの種類の数に対応しており、&lt;br&gt;
それぞれのcharactristicが各データに対応しているからです。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;if (characteristicUUIDs.length != columns.length) {
  throw new Error(&apos;Characteristic and number of columns do not match&apos;)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;入力されたlocalNameと先ほど定義したwaitDeviceを使ってデバイスを取ってきます&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const device = await waitDevice(localName)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;デバイスを取得できたらservice→characteristicと取得してsubscribeを行います。&lt;br&gt;
これでデバイスからデータを受信できるようになりました。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;// deviceと接続
await device.connectAsync()

// serviceを取得
const service = (await device.discoverServicesAsync(serviceUUIDs))[0]

// characteristicsを取得
const characteristics = await service.discoverCharacteristicsAsync(characteristicUUIDs)

// subscribeを開始
Promise.all(
  characteristics.map((characteristic) =&gt; {
    characteristic.subscribeAsync()
  })
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;続いてmongoDBへの格納をしていきます。&lt;br&gt;
やり方は色々あると思いますが今回は以下のような実装をしました&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;const colchar = Object.fromEntries(columns.map((col, index) =&gt; [col, characteristics[index]]))

await connectMongo()

for (const col in colchar) {
  colchar[col].on(&apos;data&apos;, async (data) =&gt; {
    const receivedData = data.toString()
    console.log(receivedData)
    const postData = { ...receivedData.split(&apos;,&apos;) }
    await postMongo(col, postData)
  })
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;まずcharacteristicsの配列だったものをcolumnsをkeyとしたObjectに変換します。&lt;br&gt;
これでforループを回しながらcolumnsの値とcharacteristicsの値にアクセスすることができます。&lt;br&gt;
その後、mongoDBにアクセスしたのちにforループでデータを格納していきます。&lt;/p&gt;
&lt;p&gt;最後にctl+Cで終了する前にデバイスやmongoDBとの接続を切る処理を挟み込んで終了です&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;process.on(&apos;SIGINT&apos;, async () =&gt; {
  await client.close()
  console.log(&apos;Mongo Client Close&apos;)
  device.disconnect()
  console.log(&apos;BLE Device Disconnected&apos;)
  process.exit(0)
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;各実装の紹介は以上です。&lt;br&gt;
全体のコードは&lt;a href=&quot;https://github.com/narusei/blegger&quot;&gt;リポジトリ&lt;/a&gt;をご覧ください。&lt;/p&gt;
&lt;h1&gt;確認できていないこと&lt;/h1&gt;
&lt;p&gt;本ツールは以下の点が確認できていないです&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;どのくらいのレートで送信することができるのかの検証をしていないです
&lt;ul&gt;
&lt;li&gt;デバイス側で delay をかけないで送った場合にデータが欠落する恐れがあります&lt;/li&gt;
&lt;li&gt;100msくらいは取れました&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ロガー側のデータベース保存処理を逐次的に動作させているためパフォーマンス的に良くない可能性が高いです
&lt;ul&gt;
&lt;li&gt;バッファに貯めて一括保存などの処理を挟むべきだと考えています&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;せっかく docker 使っているのに node.js 環境が必要な状態は改善したいなと感じています。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;おわりに&lt;/h1&gt;
&lt;p&gt;ケーブルをマイコンに繋げてシリアルモニタに表示されているものをコピペするという対応でも問題ないものはいいのですが、ケーブルレスでもっと色々な行動に対する加速度情報をロギングしたいといった需要があったため本CLIを作りました。もし同じような状況になった人とかいましたら是非ご活用くだされば嬉しいです。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[個人サイトを作りました！]]></title><description><![CDATA[はじめに はじめまして！執筆当時は都内で大学院生をやっていますnaruseiと申し上げます。 主にWeb技術を使ってツールやサービスをちまちまと作ったりしています。また、IoT…]]></description><link>https://narusei.github.io/blog/hello-narusite/</link><guid isPermaLink="false">https://narusei.github.io/blog/hello-narusite/</guid><pubDate>Fri, 01 Apr 2022 08:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;はじめに&lt;/h2&gt;
&lt;p&gt;はじめまして！執筆当時は都内で大学院生をやっていますnaruseiと申し上げます。&lt;/p&gt;
&lt;p&gt;主にWeb技術を使ってツールやサービスをちまちまと作ったりしています。また、IoTを絡めた実空間の情報を活用した制作物にも興味を持って取り組んでいます。&lt;/p&gt;
&lt;p&gt;したがって、主要な技術スタックとしましては&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ReactなどのWebフロントエンド&lt;/li&gt;
&lt;li&gt;Django,Rails,Node.jsなどのバックエンド&lt;/li&gt;
&lt;li&gt;BaaSとしてのfirebaseやAWS&lt;/li&gt;
&lt;li&gt;ArduinoやM5Stackなどのマイコン&lt;/li&gt;
&lt;li&gt;MQTTやLoRaWANなどの通信プロトコル&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;などに触っております。&lt;/p&gt;
&lt;p&gt;さらに詳しい自己紹介については&lt;a href=&quot;https://narusei.github.io/about&quot;&gt;こちら&lt;/a&gt;からみて頂けたら嬉しいです。&lt;/p&gt;
&lt;p&gt;…さて、本記事は表題の通り個人サイトを作ってみたというご報告をするものとなっています。
合わせて、どのように運用していきたいと考えているのかについてここに記していきたいと思っています。&lt;/p&gt;
&lt;h2&gt;本サイトについて&lt;/h2&gt;
&lt;p&gt;本サイトは著者であるnaruseiのポータル的なサイトという位置付けで運用していきたいと思っています。自身にまつわるアウトプットの全般をこのサイトに集約していきたいと考えています。&lt;/p&gt;
&lt;p&gt;現状のコンテンツとしては制作物紹介とブログとなっています。&lt;/p&gt;
&lt;h4&gt;制作物紹介&lt;/h4&gt;
&lt;p&gt;制作物紹介に関しては、実行可能な状態まで作り込んだ上で公開をしていきたいと思っています。アクセスできるリンクなども貼っておきたいと思うので是非触ってみてくれると嬉しいです。IoT関連の制作物に関しては物理的なデバイスであるため書き込んでいただきたいソースコードも公開できたらと考えています。この記事が公開された直後はまだ説明文とかがかなり簡素になっているかもしれないですが、少しつづ充実させていきたいと思っています。研究で作ったものとかはソースとかまでは紹介しないかもしれないです。&lt;/p&gt;
&lt;h4&gt;ブログ&lt;/h4&gt;
&lt;p&gt;ブログに関しては、できるだけアウトプットの敷居を下げて気軽に公開していきたいと考えています。スクラップのイメージです。流石にメモ帳レベルのものは書きませんが。&lt;/p&gt;
&lt;p&gt;あるテーマに対しての知見が固まってきたら、まとまった記事にしていきたいと考えています。その時は QiitaやZennなどに投稿したいと考えています。&lt;/p&gt;
&lt;p&gt;また、日記のような自身の考えなどをまとめたいといったアウトプットもあると思います。そういうものは一旦はてなブログなどに書いていこうかなと考えています。もしくは新しく&lt;code class=&quot;language-text&quot;&gt;Diary&lt;/code&gt;コンテンツを作成してそちらに書いていこうかなと思います。&lt;/p&gt;
&lt;h2&gt;おわりに&lt;/h2&gt;
&lt;p&gt;ひとまず初めての投稿として本サイトの方針的なものをまとめました。変わったら適宜変更していきます。&lt;/p&gt;
&lt;p&gt;次回はこのブログ作成にあたっての技術的なお話をちまちまとまとめていこうかなと思っています。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Leteto]]></title><description><![CDATA[Leteto は特定コミュニティ内での勉強会などを促進を目指したプロダクトです。 Learn Techonology Together Leteto は「一緒に技術を学ぼう」という合言葉のもとに、勉強会・LT 会・Handson…]]></description><link>https://narusei.github.io/work/leteto/</link><guid isPermaLink="false">https://narusei.github.io/work/leteto/</guid><pubDate>Sat, 01 Jan 2022 12:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Leteto は特定コミュニティ内での勉強会などを促進を目指したプロダクトです。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Le&lt;/strong&gt;arn &lt;strong&gt;Te&lt;/strong&gt;chonology &lt;strong&gt;To&lt;/strong&gt;gether&lt;/p&gt;
&lt;p&gt;Leteto は「一緒に技術を学ぼう」という合言葉のもとに、勉強会・LT 会・Handson などの開催を企画するための掲示板ツールです。&lt;/p&gt;
&lt;p&gt;使用した技術&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;React&lt;/li&gt;
&lt;li&gt;Django&lt;/li&gt;
&lt;li&gt;Heroku&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;リポジトリは&lt;a href=&quot;https://github.com/cpslab/leteto&quot;&gt;こちら&lt;/a&gt;から。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Cubetalk]]></title><description><![CDATA[…]]></description><link>https://narusei.github.io/work/cubetalk/</link><guid isPermaLink="false">https://narusei.github.io/work/cubetalk/</guid><pubDate>Mon, 23 Aug 2021 12:00:00 GMT</pubDate><content:encoded>&lt;p&gt;近年、コロナ禍の影響でソーシャルディスタンスが求められるようになったことで、家族などの身近な人とのコミュニケーションを目的とするシニア層のスマートフォン利用が促進されています。一方で、若年層と高齢者のテキスト入力速度に関して高齢者の方が入力速度が相対的に遅くなってしまうことが明らかになっており、これは家族間での円滑なコミュニケーションを実現するにあたって障壁となる可能性があリます。&lt;/p&gt;
&lt;p&gt;そこで容易な操作性を有する多面体型のタンジブルなスマートデバイスを提案します。家族間のチャットグループなどにおいて高齢者からの契機となるコミュニケーションを円滑に可能にすることを目指しています。&lt;/p&gt;
&lt;p&gt;論文は&lt;a href=&quot;https://ipsj.ixsq.nii.ac.jp/ej/index.php?active_action=repository_view_main_item_detail&amp;#x26;page_id=13&amp;#x26;block_id=8&amp;#x26;item_id=212614&amp;#x26;item_no=1&quot;&gt;こちら&lt;/a&gt;です。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Tatekae]]></title><description><![CDATA[Tatekae は”グループでの旅行”などのイベントなどで、メンバー間で起こる「立て替え」をメモするだけで、自動精算してくれる Web サービスです Tatekae の Mission は”メンドくさい精算処理から解放する”ことです。 友人や家族との旅行やキャンプや BBQ…]]></description><link>https://narusei.github.io/work/tatekae/</link><guid isPermaLink="false">https://narusei.github.io/work/tatekae/</guid><pubDate>Fri, 01 May 2020 12:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Tatekae は”グループでの旅行”などのイベントなどで、メンバー間で起こる「立て替え」をメモするだけで、自動精算してくれる Web サービスです&lt;/p&gt;
&lt;p&gt;Tatekae の Mission は”メンドくさい精算処理から解放する”ことです。&lt;/p&gt;
&lt;p&gt;友人や家族との旅行やキャンプや BBQ などで、ホテル代や夕飯の買い出しを誰かが一括で払ったり、小腹が空いたからアイス買ってきてと頼まれたりすることはありませんか？&lt;/p&gt;
&lt;p&gt;イベントにはどうしてもお金の精算がつきものですが、イベントの最中にメンドくさいお金の精算処理に気を取られて、心から楽しめないのは勿体無い！&lt;/p&gt;
&lt;p&gt;そんな問題を解決するために開発したプロダクトです。&lt;/p&gt;
&lt;p&gt;使用した技術&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Vue.js&lt;/li&gt;
&lt;li&gt;firebase&lt;/li&gt;
&lt;li&gt;Storybook&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;リポジトリは&lt;a href=&quot;https://github.com/narusei/tatekae&quot;&gt;こちら&lt;/a&gt;から。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Cuetube]]></title><description><![CDATA[CuetubeはGoogle formからYoutubeの動画IDを送信すると自動でループ再生されるツールです。 イメージとしてはカラオケのデンモクです。 もくもく会や、好きな動画の鑑賞会などをする際に活用できます。]]></description><link>https://narusei.github.io/work/cuetube/</link><guid isPermaLink="false">https://narusei.github.io/work/cuetube/</guid><pubDate>Wed, 01 May 2019 12:00:00 GMT</pubDate><content:encoded>&lt;p&gt;CuetubeはGoogle formからYoutubeの動画IDを送信すると自動でループ再生されるツールです。&lt;/p&gt;
&lt;p&gt;イメージとしてはカラオケのデンモクです。&lt;/p&gt;
&lt;p&gt;もくもく会や、好きな動画の鑑賞会などをする際に活用できます。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[About me]]></title><description><![CDATA[略歴 2017~2021 東京電機大学 未来科学部 情報メディア学科 2021~2023 東京電機大学 未来科学研究科 情報メディア学専攻 スキル テスト マークアップ（HTML5, CSS, SCSS, styled-components） フロントエンド（Javascript…]]></description><link>https://narusei.github.io/about/me/</link><guid isPermaLink="false">https://narusei.github.io/about/me/</guid><pubDate>Fri, 01 May 2015 22:12:03 GMT</pubDate><content:encoded>&lt;h4&gt;略歴&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;2017~2021 東京電機大学 未来科学部 情報メディア学科&lt;/li&gt;
&lt;li&gt;2021~2023 東京電機大学 未来科学研究科 情報メディア学専攻&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;スキル&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;テスト
&lt;ul&gt;
&lt;li&gt;マークアップ（HTML5, CSS, SCSS, styled-components）&lt;/li&gt;
&lt;li&gt;フロントエンド（Javascript, Typescript, React, Vue.js, Gatsby）&lt;/li&gt;
&lt;li&gt;UI フレームワーク（MaterialUI, tailwindcss, Bulma）&lt;/li&gt;
&lt;li&gt;バックエンド（Django, Rails, Node.js）&lt;/li&gt;
&lt;li&gt;XaaS（firebase, AWS）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;IoT
&lt;ul&gt;
&lt;li&gt;マイコン（Arduino, M5Stack）&lt;/li&gt;
&lt;li&gt;通信（BLE, MQTT, LoRaWAN）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;資格&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;基本情報技術者試験&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item></channel></rss>