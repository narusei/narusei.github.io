{
    "componentChunkName": "component---src-templates-blog-post-tsx",
    "path": "/blog/blegger/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Narusite","siteUrl":"https://narusei.github.io"}},"markdownRemark":{"id":"6427dfc4-d445-5b90-8768-131fbcdafeec","excerpt":"この記事はTDU CPSLab Advent Calendar 2022 - Adventarの10日目の記事です 前の記事はこちらから。次の記事はこちらから。 はじめに こんにちは。都内で大学生をやっているなるせいです。 今回はBluetoothを用いてデータをMongoDBへロギングするCLI…","html":"<p>この記事は<a href=\"https://adventar.org/calendars/7417\">TDU CPSLab Advent Calendar 2022 - Adventar</a>の10日目の記事です</p>\n<p>前の記事は<a href=\"\">こちら</a>から。次の記事は<a href=\"\">こちら</a>から。</p>\n<h1>はじめに</h1>\n<p>こんにちは。都内で大学生をやっているなるせいです。</p>\n<p>今回はBluetoothを用いてデータをMongoDBへロギングするCLIツールを作りましたので、記事にまとめておこうと思います。<br>\nリポジトリは<a href=\"https://github.com/narusei/blegger\">こちら</a>です。</p>\n<h1>目次</h1>\n<ul>\n<li>開発環境</li>\n<li>どんなことができるの？</li>\n<li>実装内容\n<ul>\n<li>Bluetoothデバイスの取得</li>\n<li>MongoDBにアクセスする実装</li>\n<li>CLIツールの実装</li>\n</ul>\n</li>\n<li>確認できていないこと</li>\n<li>おわりに</li>\n</ul>\n<h1>開発環境</h1>\n<p>開発にはNode.jsにTypescriptを導入して作りました。<br>\n使用したモジュールは以下の通りです。</p>\n<ul>\n<li>@abandonware/noble\n<ul>\n<li>Node.js内にてBluetoothを扱うためのモジュールです</li>\n</ul>\n</li>\n<li>mongodb\n<ul>\n<li>MongoDBサーバにアクセスするために使います</li>\n</ul>\n</li>\n<li>yargs\n<ul>\n<li>CLIツール化するために使うモジュールです</li>\n</ul>\n</li>\n</ul>\n<p>加えてMongoDBサーバをDockerを用いて立てています</p>\n<h1>どんなことができるの？</h1>\n<p>Bluetoothを扱えるマイコンにてnotifyされた際の情報を受信してMongoDBの方に格納します。<br>\nデータはStringで送信します。複数送信したい場合は以下のように送信します。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">data = data1 + \",\" + data2 + \",\" + data3</code></pre></div>\n<p>デバイス側の準備が整ったらCLIを起動します。<br>\nCLIの扱い方は以下の通りです。</p>\n<ul>\n<li>ターミナルで本リポジトリ配下を開いてください\n<ul>\n<li><code class=\"language-text\">/blegger</code>に。以下ターミナル 1 と呼称します</li>\n</ul>\n</li>\n<li>ターミナルで本リポジトリ配下の mongo フォルダを開いてください\n<ul>\n<li><code class=\"language-text\">/blegger/mongo</code>に。以下ターミナル 2 と呼称します</li>\n</ul>\n</li>\n<li>ターミナル 1 で<code class=\"language-text\">npm install</code>します</li>\n<li>ターミナル 2 で<code class=\"language-text\">docker compose up</code>します\n<ul>\n<li>古いバージョンを使っている方は<code class=\"language-text\">docker-compose up</code></li>\n</ul>\n</li>\n<li>ターミナル 1 で以下のフォーマットに従い実行します\n<ul>\n<li><code class=\"language-text\">npm start -- --name=\"YOUR_DEVICE_LOCAL_NAME\" --service=\"YOUR_SERVICE_UUID\" --characteristics=\"YOUR_CHARACTERISTIC_UUID1\" \"YOUR_CHARACTERISTIC_UUID2\" --columns=\"DATABASE_COLUMN1\" \"DATABASE_COLUMN2\"</code></li>\n</ul>\n</li>\n</ul>\n<p>オプションは以下のようになっています。<br>\n<code class=\"language-text\">npm start -- --help</code>で見ることができるヘルプと同じ内容です。</p>\n<ul>\n<li>name オプション\n<ul>\n<li>name オプションは作成した BLE デバイスのローカルネームを指します。デバイスの識別に使っています。</li>\n<li>必須オプションです。String です。</li>\n</ul>\n</li>\n<li>service オプション\n<ul>\n<li>service オプションはサービスの UUID を指定します。</li>\n<li>必須オプションです。String です。</li>\n</ul>\n</li>\n<li>characteristics オプション\n<ul>\n<li>characteristics はキャラクタリスティックの UUID を指定します。</li>\n<li>必須オプションです。Array&#x3C;String>です。配列で指定できます。columns オプションと指定した数が一致していなければなりません。</li>\n</ul>\n</li>\n<li>columns オプション\n<ul>\n<li>columns オプションはデータベースに保存する際のコレクション名です。ひとつのキャラクタリスティックにつき、ひとつのコレクションの生成をイメージしています。</li>\n<li>必須オプションです。Array&#x3C;String>です。配列で指定できます。characteristics オプションと指定した数が一致していなければなりません。</li>\n</ul>\n</li>\n</ul>\n<p>正常に動作した場合は mongoDB Compassなどからデータを確認できるはずです</p>\n<h1>実装内容</h1>\n<p>本章では各実装の簡単な説明をしていきます。<br>\n全体のコードは<a href=\"https://github.com/narusei/blegger\">リポジトリ</a>をご覧ください。</p>\n<h2>Bluetoothデバイスの取得</h2>\n<p>まずBluetoothを用いてNotifyしているデバイスを探します。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">noble.on('stateChange', async (state) => {\n  if (state === 'poweredOn') {\n    await noble.startScanningAsync()\n  } else {\n    await noble.stopScanningAsync()\n  }\n})</code></pre></div>\n<p>Scanを開始するには<code class=\"language-text\">startScanningAsync()</code>を用いればいいんですが、<br>\nその前にnobleが実装しているstateがpowerOnになっているかをチェックする必要があります。</p>\n<p><code class=\"language-text\">noble.on('stateChange', callback(state))</code>を用いることによって、<br>\nstateが変化した際にcallbackされる形になります。</p>\n<p>この時のstateがpowerOnだった場合にScanを開始しています。</p>\n<p>ちなみに<code class=\"language-text\">startScanning()</code>もありますがasync/awaitで書きたかったのでAsyncの方を使っています。</p>\n<p>次にdeviceを取得する処理を行います。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">noble.on('discover', async (peripheral: noble.Peripheral) => {\n  console.log(`${peripheral.advertisement.localName}`)\n  if (peripheral.advertisement.localName == localName) {\n    console.log('Find ' + peripheral.advertisement.localName + '!')\n  }\n})</code></pre></div>\n<p>通常は上記のような形でdiscoverというイベントを監視して、ヒットしていったdeviceのローカルネームを見比べて該当するdeviceを引っ掛けるといった形になります。しかし私としてはこの中にドンドコ処理を書いていくのはあまり良くないかなと感じたので、Promiseで包んで非同期処理で取り出せるようにしました。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const discoveryHandler = new Promise&lt;noble.Peripheral | undefined>((resolve, _reject) => {\n  console.log('Start Scanning...')\n  noble.on('discover', async (peripheral: noble.Peripheral) => {\n    console.log(`${peripheral.advertisement.localName}`)\n    if (peripheral.advertisement.localName == localName) {\n      console.log('Find ' + peripheral.advertisement.localName + '!')\n      resolve(peripheral)\n    }\n  })\n})</code></pre></div>\n<p>この関数をawaitしてnoble.Peripheralを取得するイメージになります。</p>\n<p>ただ一方で、見つからないときには恐らく永遠と探し続けるのではないかと思いました。そこでtimeoutを定義する関数を作成して、Promise.raceを用いてどっちかが解決するのを待つという形を取ることにしました。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const timeoutHandler = new Promise&lt;noble.Peripheral | undefined>((resolve, _reject) => {\n  setTimeout(() => {\n    resolve(undefined)\n  }, 30000)\n})</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const device = await Promise.race([discoveryHandler, timeoutHandler])</code></pre></div>\n<p>deviceが見つかったらListenerを全て削除します</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">noble.removeAllListeners()</code></pre></div>\n<p>以上の実装を組み合わせたdeviceを取得する関数が以下の通りになります。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const waitDevice = async (localName: string) => {\n  console.log('Start Scan &amp; Get Target Device')\n  noble.on('stateChange', async (state) => {\n    if (state === 'poweredOn') {\n      await noble.startScanningAsync()\n    } else {\n      await noble.stopScanningAsync()\n    }\n  })\n\n  const discoveryHandler = new Promise&lt;noble.Peripheral | undefined>((resolve, _reject) => {\n    console.log('Start Scanning...')\n    noble.on('discover', async (peripheral: noble.Peripheral) => {\n      console.log(`${peripheral.advertisement.localName}`)\n      if (peripheral.advertisement.localName == localName) {\n        console.log('Find ' + peripheral.advertisement.localName + '!')\n        resolve(peripheral)\n      }\n    })\n  })\n\n  const timeoutHandler = new Promise&lt;noble.Peripheral | undefined>((resolve, _reject) => {\n    setTimeout(() => {\n      resolve(undefined)\n    }, 30000)\n  })\n\n  try {\n    const device = await Promise.race([discoveryHandler, timeoutHandler])\n\n    noble.removeAllListeners()\n\n    if (device) {\n      return device\n    } else {\n      throw new Error('Device not Found')\n    }\n  } catch (e) {\n    throw new Error('Timeout')\n  }\n}</code></pre></div>\n<h2>MongoDBにアクセスする実装</h2>\n<p>次にmongoDBにアクセスする関数を用意します。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const connectMongo = async () => {\n  try {\n    await client.connect()\n    await client.db('admin').command({ ping: 1 })\n    console.log('Connected successfully to server')\n  } catch (error) {\n    console.log(error)\n  }\n}\n\nconst postMongo = async (colName: string, data: mongoDB.Document) => {\n  try {\n    const dbSensing = await client.db('sensing')\n    const colSensing = dbSensing.collection(colName)\n    const result = await colSensing.insertOne(data)\n    return result\n  } catch (error) {\n    console.log(error)\n  }\n}</code></pre></div>\n<h2>CLIツールの実装</h2>\n<p>ここまで実装を終えたら準備は整いました。<br>\nあとはyargsを使ってCLIツール化していきます。</p>\n<p>まずcliで受け入れるコマンドの定義をしていきます。<br>\n前節で述べたオプションを指定していきます。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const argv = await yargs\n    .option('name', {\n      alias: 'nm',\n      description: 'ロギングを行うデバイスのLocalNameを指定してください',\n      demandOption: true,\n      type: 'string',\n    })\n    .option('service', {\n      alias: 'ser',\n      description: 'ロギングを行いたいServiceのUUIDを指定してください',\n      demandOption: true,\n      type: 'string',\n    })\n    .option('characteristics', {\n      alias: 'char',\n      description: 'ロギングを行いたいCharacteristicのUUIDを指定してください',\n      demandOption: true,\n      type: 'array',\n    })\n    .option('columns', {\n      alias: 'col',\n      description: 'データのコレクション名を書いてください',\n      demandOption: true,\n      type: 'array',\n    })\n    .help().argv</code></pre></div>\n<p>以上のような感じで受け入れオプションを設定します。<br>\n以降、<code class=\"language-text\">argv.name</code>といった形でユーザが入力した値を取得することができます。</p>\n<p>それでは入力値を変数に格納していきます。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const localName = argv.name ? argv.name : ''\nconst serviceUUIDs = argv.service ? [argv.service] : []\nconst characteristicUUIDs: string[] = argv.characteristics.map((value) => {\n  return value.toString()\n})\nconst columns: string[] = argv.columns.map((value) => {\n  return value.toString()\n})</code></pre></div>\n<p>また、characteristicの数はcolumnsの数と同じだけ存在する必要があります。<br>\ncolumnsはDBに保管するときのデータの種類の数に対応しており、<br>\nそれぞれのcharactristicが各データに対応しているからです。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">if (characteristicUUIDs.length != columns.length) {\n  throw new Error('Characteristic and number of columns do not match')\n}</code></pre></div>\n<p>入力されたlocalNameと先ほど定義したwaitDeviceを使ってデバイスを取ってきます</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const device = await waitDevice(localName)</code></pre></div>\n<p>デバイスを取得できたらservice→characteristicと取得してsubscribeを行います。<br>\nこれでデバイスからデータを受信できるようになりました。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// deviceと接続\nawait device.connectAsync()\n\n// serviceを取得\nconst service = (await device.discoverServicesAsync(serviceUUIDs))[0]\n\n// characteristicsを取得\nconst characteristics = await service.discoverCharacteristicsAsync(characteristicUUIDs)\n\n// subscribeを開始\nPromise.all(\n  characteristics.map((characteristic) => {\n    characteristic.subscribeAsync()\n  })\n)</code></pre></div>\n<p>続いてmongoDBへの格納をしていきます。<br>\nやり方は色々あると思いますが今回は以下のような実装をしました</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const colchar = Object.fromEntries(columns.map((col, index) => [col, characteristics[index]]))\n\nawait connectMongo()\n\nfor (const col in colchar) {\n  colchar[col].on('data', async (data) => {\n    const receivedData = data.toString()\n    console.log(receivedData)\n    const postData = { ...receivedData.split(',') }\n    await postMongo(col, postData)\n  })\n}</code></pre></div>\n<p>まずcharacteristicsの配列だったものをcolumnsをkeyとしたObjectに変換します。<br>\nこれでforループを回しながらcolumnsの値とcharacteristicsの値にアクセスすることができます。<br>\nその後、mongoDBにアクセスしたのちにforループでデータを格納していきます。</p>\n<p>最後にctl+Cで終了する前にデバイスやmongoDBとの接続を切る処理を挟み込んで終了です</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">process.on('SIGINT', async () => {\n  await client.close()\n  console.log('Mongo Client Close')\n  device.disconnect()\n  console.log('BLE Device Disconnected')\n  process.exit(0)\n})</code></pre></div>\n<p>各実装の紹介は以上です。<br>\n全体のコードは<a href=\"https://github.com/narusei/blegger\">リポジトリ</a>をご覧ください。</p>\n<h1>確認できていないこと</h1>\n<p>本ツールは以下の点が確認できていないです</p>\n<ul>\n<li>どのくらいのレートで送信することができるのかの検証をしていないです\n<ul>\n<li>デバイス側で delay をかけないで送った場合にデータが欠落する恐れがあります</li>\n<li>100msくらいは取れました</li>\n</ul>\n</li>\n<li>ロガー側のデータベース保存処理を逐次的に動作させているためパフォーマンス的に良くない可能性が高いです\n<ul>\n<li>バッファに貯めて一括保存などの処理を挟むべきだと考えています</li>\n</ul>\n</li>\n<li>せっかく docker 使っているのに node.js 環境が必要な状態は改善したいなと感じています。</li>\n</ul>\n<h1>おわりに</h1>\n<p>ケーブルをマイコンに繋げてシリアルモニタに表示されているものをコピペするという対応でも問題ないものはいいのですが、ケーブルレスでもっと色々な行動に対する加速度情報をロギングしたいといった需要があったため本CLIを作りました。もし同じような状況になった人とかいましたら是非ご活用くだされば嬉しいです。</p>","fields":{"slug":"/blog/blegger/"},"frontmatter":{"title":"Bluetoothを用いてデータをMongoDBへロギングするCLIツールを作りました","date":"December 23, 2022","description":"BLEを使ったロギングCLIツールを作った話","tags":["ble","mongodb","cli-tool","logger"]}},"previous":{"fields":{"slug":"/blog/hello-narusite/"},"frontmatter":{"title":"個人サイトを作りました！"}},"next":null},"pageContext":{"id":"6427dfc4-d445-5b90-8768-131fbcdafeec","previousPostId":"938073bd-c2dc-5357-9351-2ddd40f8c767","nextPostId":null}},
    "staticQueryHashes": ["3768634532"]}